# 7 - actions - stores - reducers

* Actions

  * represent user intent
  * must have a type

* Store

  * pass reducer to createStore

  * api
    * `store.dispath(action)`
    * `store.subscribe(listener)`
    * `store.getState()`
    * `replaceReducer(nextReducer)`

* immutability

  * to change state must return a new object
  * `Object.assing({}, state, {role: 'admin'});`
  * Spread operator
  * primitive types already immutable
  * redux-immutable-state-invariant (only in dev)
  * Immutable.js (will programmatically enforce)

* Reducers

  * ```
    function myReducer(state, action) {
      // return new state based on aciton
    }
    ```
  * NEVER IN A REDUCER:
    * Mutate arguments
    * perform side effects
    * call non-pure functions
  * 1 store, multiple reducers
  * all reducers are called and a reducer must return untouched state as default if no switch case matches

# 8 - connecting react to redux

* containers
  * Focus on how things work
  * Aware of Redux
  * Subscribe to Redux State
  * Dispatch Redux actions
  * Generated by react-redux
* presentational

  * Focus on how things work
  * Aware of Redux
  * Subscribe to Redux State
  * Dispatch Redux actions
  * Generated by react-redux

* react-redux

  * Provider

    * Attaches app to store

    * ```
      <Provider store={this.props.store}>
        <App />
      </Provider>
      ```

  * Connect

    * creates container components
    * ```
      # determines what state will be available on function via props
      # filter or transform state
      function mapStateToProps(state, ownProps) {
        return {appState: state.authorReducer};
      }
      ```


      export default connect(
        mapStateToProps,
        mapDispatchToProps
      )(AuthorPage);
      ```

    * handles unsubscribes, and lifecycle stuff

    * ```
      connect(mapStateToProps, mapDispatchToProps)

      function mapStateToProps(state) {
        return {
          appState: state
        };
      }
      ```

    * Memoize reselect to reduce expensive mapStateToProps work can increase performance, filter list or making expensive calcs
    * like caching for function calls since mapStateToProps is called often
    * what actions to expose not what state
    * ```
      function mapDispathToProps(dispatch) {
        return {
          actions: bindActionCreators(actions, dispatch)
        };
      }
      ```

        * how to expose actions to proponents
          1. ignore - and call manually in componenets (doesnt abstract redux)
          2. manually wraper (lets do this to start?)
          3. bindActionsCreators (most magical) - actions
        * makes easier to pass down to child components


    * 5 major peices of a container component w/ redux
      1. constructor
      2. child functions
      3. render
      4. propTypes
      5. redux connect and related functions
