# 7 - actions - stores - reducers

* Actions

  * represent user intent
  * must have a type

* Store

  * pass reducer to createStore

  * api
    * `store.dispath(action)`
    * `store.subscribe(listener)`
    * `store.getState()`
    * `replaceReducer(nextReducer)`

* immutability

  * to change state must return a new object
  * `Object.assing({}, state, {role: 'admin'});`
  * Spread operator
  * primitive types already immutable
  * redux-immutable-state-invariant (only in dev)
  * Immutable.js (will programmatically enforce)

* Reducers

  * ```
    function myReducer(state, action) {
      // return new state based on aciton
    }
    ```
  * NEVER IN A REDUCER:
    * Mutate arguments
    * perform side effects
    * call non-pure functions
  * 1 store, multiple reducers
  * all reducers are called and a reducer must return untouched state as default if no switch case matches

# 8 - connecting react to redux

* containers
  * Focus on how things work
  * Aware of Redux
  * Subscribe to Redux State
  * Dispatch Redux actions
  * Generated by react-redux
* presentational

  * Focus on how things work
  * Aware of Redux
  * Subscribe to Redux State
  * Dispatch Redux actions
  * Generated by react-redux

* react-redux

  * Provider

    * Attaches app to store

    * ```
      <Provider store={this.props.store}>
        <App />
      </Provider>
      ```

  * Connect

    * creates container components
    * ```
      # determines what state will be available on function via props
      # filter or transform state
      function mapStateToProps(state, ownProps) {
        return {appState: state.authorReducer};
      }
      ```


      export default connect(
        mapStateToProps,
        mapDispatchToProps
      )(AuthorPage);
      ```

    * handles unsubscribes, and lifecycle stuff

    * ```
      connect(mapStateToProps, mapDispatchToProps)

      function mapStateToProps(state) {
        return {
          appState: state
        };
      }
      ```

    * Memoize reselect to reduce expensive mapStateToProps work can increase performance, filter list or making expensive calcs
    * like caching for function calls since mapStateToProps is called often
    * what actions to expose not what state
    * ```
      function mapDispathToProps(dispatch) {
        return {
          actions: bindActionCreators(actions, dispatch)
        };
      }
      ```

        * how to expose actions to proponents
          1. ignore - and call manually in componenets (doesnt abstract redux)
          2. manually wraper (lets do this to start?)
          3. bindActionsCreators (most magical) - actions
        * makes easier to pass down to child components


    * 5 major peices of a container component w/ redux
      1. constructor
      2. child functions
      3. render
      4. propTypes
      5. redux connect and related functions

# Async

* middleware - libraries

  * thunk - dan a.
    * function instead of objects
    * clunky to test
    * easy to learn
  * promise
  * saga (es6 generators) - dsl

    * generators (yeild statements)
    * easier to test
    * harder to learn

  * thunk example
  * return a function from a function

  ```
  export function deleteAuthor(authorID) {
    return dispatch => {
      return AuthorApi.deleteAuthor(authorID).then(() => {
        dispatch(deletedAuthor(authorId));
      }).catch(handleError)
    }
  }
  ```

* action naming conventions

  * \_SUCCESS
  * \_FAILURE or \_ERROR

* REDUX!
* "Remember, Redux is most useful for larger complex apps. On trivial apps like this, the boilerplate may feel tedious, but the larger the app and the more comfortable that you get with this flow, the more this architecture is going to pay off in scalability, maintainability, and clarity through consistency."

# Testing

* framework - mocha (alt. AVA, Jasmine, Jest)
* assertion library - expect (alt. chai)
* helper library for test

  * react test utils - NOT TERSE
    * shallowRender, single component, no DOM
    * renderIntoDocument, DOM required, findRenderedDOMComponent
    * Simulate (event, clicks, keypress, etc)
  * Enzyme
    * find (more like jquery)
    * shallow rendering
    * check api docs on airbnb github
  * What is Enzyme
    * abstraction ontop of React Test Utils
    * JSDOM (in memory DOM)
    * CHeerio (jquery like selectors)

* Where to test

  * karma
  * headless browser phantomJS
  * In-memory DOM

* Where to place test

  * ALONG SIDE !!!
  * CLEAR VISIBILITY
  * Easy Imports
  * easy to open both at same time
  * easy to refactor

* Test presentation components first
* Shallow Render (no refs or interactions) vs Render into Document

# Testing Redux

* Action creators
* Thunks
* Reducers
* Store

* Testing Container Components - 2 options

  * General

    * Wrap with <Provider> - customs store for test
    * Add named export for unconnected componenet

    * use mount instead of shallow

  * MapStateToProps

    * extract to simple plain old functions and test those

  * Actions

    * silly to test because they just wrapp in object with type
    * test is just a duplicate delclaration

  * Testing Reducers

    * redux test recorder?
    * they are just pure functions so easy to test

  * Testing Thunks

    * needs Mock

  * Testing the store

    * integration testing
